<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DULAS — Advanced Encoder</title>
<style>
  :root{
    --bg1:#14142b; --bg2:#2b2a59;
    --card: rgba(255,255,255,0.06);
    --accent:#7c5cff;
    --accent-2:#00d4ff;
    --btn:#00c6ff;
    --success: #00c896;
    --error: #ff4d7c;
    --warning: #ffb44d;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body{
    margin:0; min-height:100vh;
    background: linear-gradient(180deg,var(--bg1),var(--bg2));
    color:#eaf0ff; display:flex; align-items:center; justify-content:center;
    padding:18px;
  }
  .wrap{
    width:100%; max-width:920px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.1));
    border-radius:14px; padding:18px; box-shadow: 0 8px 40px rgba(2,6,23,0.6);
  }
  header{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  h1{margin:0; font-size:20px; letter-spacing:0.2px}
  .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  select,input[type="file"]{padding:10px 12px; border-radius:10px; border:none; background:var(--card); color:inherit;}
  input[type="password"]{padding:10px 12px; border-radius:10px; border:none; background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit;}
  button.primary{
    background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#012; border:none; padding:10px 16px; border-radius:10px; cursor:pointer;
    box-shadow: 0 6px 18px rgba(124,92,255,0.18), inset 0 -2px 0 rgba(0,0,0,0.12);
    transition: all 0.2s ease;
  }
  button.primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 22px rgba(124,92,255,0.25), inset 0 -2px 0 rgba(0,0,0,0.12);
  }
  button.primary:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }
  .main{display:flex; gap:16px; margin-top:14px; flex-wrap:wrap}
  .left{flex:1; min-width:240px}
  .right{width:360px; max-width:100%; background:rgba(255,255,255,0.02); padding:12px; border-radius:12px; height:420px; overflow:auto}
  .file-list{display:flex; flex-direction:column; gap:10px}
  .file-item{display:flex; gap:10px; align-items:center; background:rgba(0,0,0,0.25); padding:8px; border-radius:8px; position: relative;}
  .file-item .remove-btn {
    position: absolute;
    top: -5px;
    right: -5px;
    background: var(--error);
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .thumb{width:52px; height:52px; border-radius:8px; display:flex; align-items:center; justify-content:center; overflow:hidden; background:rgba(255,255,255,0.03)}
  .thumb img{width:100%; height:100%; object-fit:cover}
  .meta{flex:1; min-width:0}
  .meta .name{font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .meta .sub{font-size:12px; opacity:0.7}
  .download-links{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
  a.dl{padding:8px 12px; border-radius:8px; background:linear-gradient(90deg,#e9f0ff, #c8e9ff); color:#013; text-decoration:none; font-weight:600; display:inline-block; transition: all 0.2s ease;}
  a.dl:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  .hint{font-size:13px; opacity:0.8}
  .footer{margin-top:12px; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  .progress-bar {
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 8px;
    display: none;
  }
  .progress-bar .progress {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent-2));
    width: 0%;
    transition: width 0.3s ease;
  }
  .status-message {
    padding: 8px 12px;
    border-radius: 6px;
    margin-top: 10px;
    font-size: 13px;
    display: none;
  }
  .status-success {
    background: rgba(0,200,150,0.15);
    color: var(--success);
    display: block;
  }
  .status-error {
    background: rgba(255,77,124,0.15);
    color: var(--error);
    display: block;
  }
  .password-strength {
    height: 4px;
    border-radius: 2px;
    margin-top: 6px;
    transition: all 0.3s ease;
  }
  .strength-0 { background: var(--error); width: 25%; }
  .strength-1 { background: #ff6b4d; width: 50%; }
  .strength-2 { background: var(--warning); width: 75%; }
  .strength-3 { background: var(--success); width: 100%; }
  .compression-info {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 10px;
    font-size: 13px;
    opacity: 0.8;
  }
  .compression-badge {
    padding: 2px 6px;
    border-radius: 4px;
    background: rgba(0,200,150,0.2);
    color: var(--success);
    font-size: 11px;
  }
  @media (max-width:700px){
    .main{flex-direction:column}
    .right{height:320px}
    .controls {
      flex-direction: column;
      align-items: stretch;
    }
  }
</style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div>
        <h1>DULAS Advanced Encoder</h1>
        <div class="hint">Create a private .dls container (images, audio, video, PDF). Up to 10 files</div>
      </div>

      <div class="controls" aria-hidden="false">
        <label for="typeSelect" class="hint">Type:</label>
        <select id="typeSelect" aria-label="Choose type">
          <option value="image">Images</option>
          <option value="audio">Audio</option>
          <option value="video">Video</option>
          <option value="pdf">PDF</option>
        </select>

        <input id="fileInput" type="file" multiple aria-label="Choose files (up to 10)" accept="*/*"/>

        <input id="pass" type="password" placeholder="Optional password" aria-label="password">
        <div id="passwordStrength" class="password-strength strength-0"></div>

        <button class="primary" id="encodeBtn">Encode → .dls</button>
      </div>
    </header>

    <div class="main">
      <div class="left">
        <div style="background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:12px;">
          <strong>Selected files</strong>
          <div class="compression-info">
            <label for="compressionLevel">Compression:</label>
            <select id="compressionLevel">
              <option value="0">None</option>
              <option value="1" selected>Fast</option>
              <option value="2">Balanced</option>
              <option value="3">Maximum</option>
            </select>
            <span class="compression-badge" id="compressionBadge">LZ77 + Huffman</span>
          </div>
          <div class="progress-bar" id="encodeProgress">
            <div class="progress"></div>
          </div>
          <div id="selectedArea" style="margin-top:10px">
            <div class="hint">Choose files. Thumbnails will appear here.</div>
          </div>
        </div>

        <div style="margin-top:10px">
          <button id="clearBtn" style="padding:10px;border-radius:10px;border:none;background:#333;color:#fff">Clear selection</button>
        </div>

        <div id="statusMessage" class="status-message"></div>

      </div>

      <aside class="right" aria-live="polite">
        <strong>Output & Downloads</strong>
        <div id="outputArea" style="margin-top:10px">
          <div class="hint">When encoding completes, download links will appear here.</div>
        </div>
      </aside>
    </div>

    <div class="footer">
      <div class="hint">DULAS format v1.2 — encrypted binary container with compression</div>
      <div class="hint">Files will be packaged individually (one .dls per original file)</div>
    </div>
  </div>

<script>
/* Utility: text <-> bytes */
const enc = new TextEncoder();
const dec = new TextDecoder();

/* Password strength calculator */
function calculatePasswordStrength(password) {
  if (!password) return 0;
  
  let strength = 0;
  
  // Length check
  if (password.length >= 8) strength += 1;
  if (password.length >= 12) strength += 1;
  
  // Complexity checks
  if (/[A-Z]/.test(password)) strength += 1; // Uppercase letters
  if (/[a-z]/.test(password)) strength += 1; // Lowercase letters
  if (/[0-9]/.test(password)) strength += 1; // Numbers
  if (/[^A-Za-z0-9]/.test(password)) strength += 1; // Special characters
  
  // Cap at 3 for our UI
  return Math.min(strength, 3);
}

/* Modern password-based key derivation with salt and iterations */
async function deriveEncryptionKey(password, salt) {
  if (!password) return null;
  
  const encoder = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    encoder.encode(password),
    { name: 'PBKDF2' },
    false,
    ['deriveBits', 'deriveKey']
  );
  
  const key = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 100000,
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
  
  return key;
}

/* Compress data using a simple LZ77-inspired algorithm */
async function compressData(data, level = 1) {
  if (level === 0) return data; // No compression
  
  try {
    // For level 1 (fast), use simpler compression
    if (level === 1) {
      // Simple run-length encoding for repetitive data
      const compressed = [];
      let i = 0;
      
      while (i < data.length) {
        // Look for sequences of repeating bytes
        let repeatCount = 1;
        const currentByte = data[i];
        
        while (i + repeatCount < data.length && 
               data[i + repeatCount] === currentByte && 
               repeatCount < 255) {
          repeatCount++;
        }
        
        if (repeatCount > 3) {
          // Use RLE encoding for sequences longer than 3
          compressed.push(0xFF, currentByte, repeatCount);
          i += repeatCount;
        } else {
          // Copy literal bytes
          compressed.push(data[i++]);
        }
      }
      
      return new Uint8Array(compressed);
    }
    
    // For higher compression levels, use more advanced techniques
    if (level >= 2) {
      // More advanced LZ77-style compression
      const compressed = [];
      const windowSize = level === 2 ? 1024 : 4096; // Larger window for higher levels
      let position = 0;
      
      while (position < data.length) {
        let bestMatch = { offset: 0, length: 0 };
        
        // Search for matches in the sliding window
        const searchStart = Math.max(0, position - windowSize);
        for (let i = searchStart; i < position; i++) {
          let matchLength = 0;
          
          // Find length of matching sequence
          while (position + matchLength < data.length && 
                 data[i + matchLength] === data[position + matchLength] &&
                 matchLength < 258) { // Maximum match length
            matchLength++;
          }
          
          if (matchLength > bestMatch.length && matchLength > 3) {
            bestMatch = { offset: position - i, length: matchLength };
          }
        }
        
        if (bestMatch.length > 0) {
          // Encode as (offset, length) pair
          compressed.push(0xFE); // Marker for LZ77 sequence
          compressed.push(bestMatch.offset >> 8);
          compressed.push(bestMatch.offset & 0xFF);
          compressed.push(bestMatch.length);
          position += bestMatch.length;
        } else {
          // Encode as literal byte
          if (data[position] === 0xFE || data[position] === 0xFF) {
            compressed.push(0xFD); // Escape character
          }
          compressed.push(data[position++]);
        }
      }
      
      return new Uint8Array(compressed);
    }
  } catch (error) {
    console.error("Compression error:", error);
    // Fall back to no compression if anything fails
    return data;
  }
  
  return data;
}

/* Encrypt data using AES-GCM */
async function encryptData(data, key, iv) {
  try {
    const encrypted = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: iv
      },
      key,
      data
    );
    
    return new Uint8Array(encrypted);
  } catch (error) {
    console.error("Encryption error:", error);
    throw new Error("Failed to encrypt data");
  }
}

/* Create a single .dls file with enhanced structure:
   [MAGIC 'DULAS' 5 bytes][VERSION 1 byte][TYPE 1 byte:1=image,2=audio,3=video,4=pdf]
   [FLAG byte: bit0=passwordProtected, bit1=compressed, bit2=usesModernCrypto]
   [salt 16 bytes][iv 12 bytes - if passwordProtected]
   [compressionLevel 1 byte - if compressed]
   [nameLen 2 bytes big-endian][nameBytes UTF-8]
   [metaLen 4 bytes big-endian][metaBytes UTF-8]
   [contentBytes...]  (encrypted if passwordProtected)
*/
async function packDulas(fileName, fileType, metaObj, contentBytes, password, compressionLevel) {
  const MAGIC = 'DULAS';
  
  // Convert type to byte code
  const typeMap = { image: 1, audio: 2, video: 3, pdf: 4 };
  const typeByte = typeMap[fileType] || 0;
  
  const nameBytes = enc.encode(fileName);
  const metaStr = JSON.stringify(metaObj);
  const metaBytes = enc.encode(metaStr);

  let flags = 0;
  let salt = new Uint8Array(0);
  let iv = new Uint8Array(0);
  let compressionByte = 0;
  let finalContent = contentBytes;
  
  // Apply compression if requested
  if (compressionLevel > 0) {
    try {
      finalContent = await compressData(contentBytes, compressionLevel);
      flags |= 2; // Set compressed flag
      compressionByte = compressionLevel;
    } catch (error) {
      console.warn("Compression failed, using uncompressed data:", error);
      // Continue without compression
    }
  }
  
  // Encrypt contentBytes if password is provided
  if (password) {
    flags |= 1; // Set password protected flag
    flags |= 4; // Set modern crypto flag
    
    // Generate random salt and IV
    salt = crypto.getRandomValues(new Uint8Array(16));
    iv = crypto.getRandomValues(new Uint8Array(12));
    
    try {
      const key = await deriveEncryptionKey(password, salt);
      finalContent = await encryptData(finalContent, key, iv);
    } catch (error) {
      console.error("Encryption failed:", error);
      throw new Error("Password processing failed");
    }
  }

  // Calculate total size
  const totalSize = 
    5 + 1 + 1 + 1 + // Magic, version, type, flags
    (flags & 1 ? salt.length + iv.length : 0) + // Salt + IV if encrypted
    (flags & 2 ? 1 : 0) + // Compression level byte if compressed
    2 + nameBytes.length + // Name length + name
    4 + metaBytes.length + // Meta length + meta
    finalContent.length; // Content

  const out = new Uint8Array(totalSize);
  let p = 0;
  
  // MAGIC
  for (let i = 0; i < 5; i++) out[p++] = MAGIC.charCodeAt(i);
  out[p++] = 1; // version
  out[p++] = typeByte;
  out[p++] = flags & 0xff;
  
  // Salt and IV if encrypted
  if (flags & 1) {
    out.set(salt, p);
    p += salt.length;
    out.set(iv, p);
    p += iv.length;
  }
  
  // Compression level if compressed
  if (flags & 2) {
    out[p++] = compressionByte;
  }
  
  // Name length (2 bytes big-endian)
  out[p++] = (nameBytes.length >> 8) & 0xff;
  out[p++] = nameBytes.length & 0xff;
  out.set(nameBytes, p);
  p += nameBytes.length;
  
  // Meta length (4 bytes BE)
  out[p++] = (metaBytes.length >>> 24) & 0xff;
  out[p++] = (metaBytes.length >>> 16) & 0xff;
  out[p++] = (metaBytes.length >>> 8) & 0xff;
  out[p++] = (metaBytes.length) & 0xff;
  out.set(metaBytes, p);
  p += metaBytes.length;
  
  // Content
  out.set(finalContent, p);
  
  return {
    data: out,
    originalSize: contentBytes.length,
    compressedSize: finalContent.length,
    compressed: (flags & 2) !== 0,
    encrypted: (flags & 1) !== 0
  };
}

/* Helper to convert ArrayBuffer to Blob download link */
function blobToLink(uint8arr, suggestedName) {
  const blob = new Blob([uint8arr], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = suggestedName;
  a.className = 'dl';
  a.textContent = `Download ${suggestedName}`;
  a.setAttribute('aria-label', `Download ${suggestedName}`);
  return a;
}

/* UI wiring */
const fileInput = document.getElementById('fileInput');
const typeSelect = document.getElementById('typeSelect');
const passInput = document.getElementById('pass');
const encodeBtn = document.getElementById('encodeBtn');
const selectedArea = document.getElementById('selectedArea');
const outputArea = document.getElementById('outputArea');
const clearBtn = document.getElementById('clearBtn');
const encodeProgress = document.getElementById('encodeProgress');
const progressBar = encodeProgress.querySelector('.progress');
const statusMessage = document.getElementById('statusMessage');
const passwordStrength = document.getElementById('passwordStrength');
const compressionLevel = document.getElementById('compressionLevel');
const compressionBadge = document.getElementById('compressionBadge');

let currentFiles = [];

// Update password strength indicator
passInput.addEventListener('input', () => {
  const strength = calculatePasswordStrength(passInput.value);
  passwordStrength.className = `password-strength strength-${strength}`;
});

// Update compression badge text
compressionLevel.addEventListener('change', () => {
  const level = parseInt(compressionLevel.value);
  const badges = [
    "None",
    "Fast (RLE)",
    "Balanced (LZ77)",
    "Maximum (LZ77)"
  ];
  compressionBadge.textContent = badges[level] || "Unknown";
});

fileInput.addEventListener('change', e => {
  const files = Array.from(e.target.files).slice(0, 10); // cap 10
  currentFiles = files;
  renderSelected();
});

typeSelect.addEventListener('change', () => { renderSelected(); });

clearBtn.addEventListener('click', () => {
  currentFiles = [];
  fileInput.value = '';
  renderSelected();
  outputArea.innerHTML = '<div class="hint">Cleared.</div>';
  hideStatus();
});

function showStatus(message, type = 'success') {
  statusMessage.textContent = message;
  statusMessage.className = `status-message status-${type}`;
}

function hideStatus() {
  statusMessage.style.display = 'none';
}

function showProgress(percent) {
  encodeProgress.style.display = 'block';
  progressBar.style.width = `${percent}%`;
}

function hideProgress() {
  encodeProgress.style.display = 'none';
}

function renderSelected() {
  if (currentFiles.length === 0) {
    selectedArea.innerHTML = '<div class="hint">Choose files. Thumbnails will appear here.</div>';
    return;
  }
  
  const list = document.createElement('div');
  list.className = 'file-list';
  
  currentFiles.forEach((f, idx) => {
    const item = document.createElement('div');
    item.className = 'file-item';
    item.dataset.index = idx;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.innerHTML = '×';
    removeBtn.title = 'Remove file';
    removeBtn.addEventListener('click', () => {
      currentFiles.splice(idx, 1);
      renderSelected();
    });
    
    const thumb = document.createElement('div');
    thumb.className = 'thumb';
    
    const meta = document.createElement('div');
    meta.className = 'meta';
    
    const nm = document.createElement('div');
    nm.className = 'name';
    nm.textContent = f.name;
    
    const sub = document.createElement('div');
    sub.className = 'sub';
    sub.textContent = `${(f.size / 1024).toFixed(1)} KB • ${f.type || 'unknown'}`;
    
    meta.appendChild(nm);
    meta.appendChild(sub);
    
    // Thumbnail preview based on file type
    const fileType = typeSelect.value;
    if (fileType === 'image' && f.type.startsWith('image/')) {
      const img = document.createElement('img');
      img.alt = f.name;
      thumb.appendChild(img);
      const reader = new FileReader();
      reader.onload = ev => img.src = ev.target.result;
      reader.readAsDataURL(f);
    } else if (fileType === 'pdf' && f.type === 'application/pdf') {
      thumb.innerHTML = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM15 18H9v-2h6v2zm0-4H9v-2h6v2zm-2-4V9.5L15.5 10H13z" fill="currentColor"/></svg>';
    } else if (fileType === 'video' && f.type.startsWith('video/')) {
      thumb.innerHTML = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" fill="currentColor"/></svg>';
    } else {
      // Audio or fallback
      thumb.innerHTML = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 10v4h4l5 5V5L7 10H3z" fill="currentColor"/></svg>';
    }
    
    item.appendChild(removeBtn);
    item.appendChild(thumb);
    item.appendChild(meta);
    list.appendChild(item);
  });
  
  selectedArea.innerHTML = '';
  selectedArea.appendChild(list);
}

encodeBtn.addEventListener('click', async () => {
  if (currentFiles.length === 0) {
    showStatus('No files selected', 'error');
    return;
  }
  
  const chosenType = typeSelect.value;
  const compLevel = parseInt(compressionLevel.value);
  encodeBtn.disabled = true;
  showProgress(0);
  hideStatus();
  
  outputArea.innerHTML = '<div class="hint">Encoding...</div>';
  
  try {
    const password = passInput.value ? passInput.value : null;
    const results = [];
    
    for (let i = 0; i < currentFiles.length; i++) {
      const f = currentFiles[i];
      showProgress((i / currentFiles.length) * 100);
      
      // Basic type validation
      if (chosenType === 'image' && !f.type.startsWith('image/')) {
        showStatus(`File "${f.name}" is not an image. Skipping.`, 'error');
        continue;
      }
      if (chosenType === 'audio' && !f.type.startsWith('audio/')) {
        showStatus(`File "${f.name}" is not an audio file. Skipping.`, 'error');
        continue;
      }
      if (chosenType === 'video' && !f.type.startsWith('video/')) {
        showStatus(`File "${f.name}" is not a video file. Skipping.`, 'error');
        continue;
      }
      if (chosenType === 'pdf' && f.type !== 'application/pdf') {
        showStatus(`File "${f.name}" is not a PDF. Skipping.`, 'error');
        continue;
      }
      
      try {
        // Read file as ArrayBuffer
        const arr = await f.arrayBuffer();
        const bytes = new Uint8Array(arr);
        const meta = {
          originalType: f.type || '',
          originalSize: f.size,
          createdAt: new Date().toISOString(),
          originalName: f.name
        };
        
        const packaged = await packDulas(f.name, chosenType, meta, bytes, password, compLevel);
        const suggestedName = f.name.replace(/\.[^/.]+$/, '') + '.dls';
        
        results.push({
          file: f,
          packaged: packaged.data,
          suggestedName: suggestedName,
          originalSize: packaged.originalSize,
          compressedSize: packaged.compressedSize,
          compressed: packaged.compressed,
          encrypted: packaged.encrypted
        });
      } catch (error) {
        console.error(`Error processing ${f.name}:`, error);
        showStatus(`Error processing ${f.name}: ${error.message}`, 'error');
      }
    }
    
    showProgress(100);
    outputArea.innerHTML = '';
    
    if (results.length === 0) {
      outputArea.innerHTML = '<div class="hint">No files were successfully encoded.</div>';
      showStatus('Encoding completed with errors', 'error');
    } else {
      let totalOriginalSize = 0;
      let totalCompressedSize = 0;
      
      results.forEach(result => {
        totalOriginalSize += result.originalSize;
        totalCompressedSize += result.compressedSize;
        
        const link = blobToLink(result.packaged, result.suggestedName);
        
        const box = document.createElement('div');
        box.style.marginBottom = '12px';
        box.appendChild(link);
        
        const info = document.createElement('div');
        info.className = 'hint';
        info.style.marginTop = '6px';
        
        let infoText = `Type: ${chosenType} • `;
        infoText += result.encrypted ? 'Encrypted • ' : 'No encryption • ';
        infoText += result.compressed ? 
          `Compressed: ${(result.originalSize/1024).toFixed(1)}KB → ${(result.compressedSize/1024).toFixed(1)}KB (${(100 - (result.compressedSize/result.originalSize * 100)).toFixed(1)}% saved) • ` : 
          'Not compressed • ';
        infoText += result.file.name;
        
        info.textContent = infoText;
        box.appendChild(info);
        
        outputArea.appendChild(box);
      });
      
      // Add summary
      const summary = document.createElement('div');
      summary.className = 'hint';
      summary.style.marginBottom = '12px';
      summary.style.padding = '8px';
      summary.style.background = 'rgba(255,255,255,0.05)';
      summary.style.borderRadius = '6px';
      
      let summaryText = `Encoded ${results.length} file(s). `;
      if (compLevel > 0) {
        const compressionRatio = (100 - (totalCompressedSize / totalOriginalSize * 100)).toFixed(1);
        summaryText += `Compression: ${(totalOriginalSize/1024).toFixed(1)}KB → ${(totalCompressedSize/1024).toFixed(1)}KB (${compressionRatio}% saved). `;
      }
      summaryText += results.some(r => r.encrypted) ? 'Files are encrypted.' : 'Files are not encrypted.';
      
      summary.textContent = summaryText;
      outputArea.insertBefore(summary, outputArea.firstChild);
      
      showStatus(`Successfully encoded ${results.length} file(s)`, 'success');
    }
  } catch (error) {
    console.error('Encoding error:', error);
    outputArea.innerHTML = '<div class="hint">An error occurred during encoding.</div>';
    showStatus(`Encoding error: ${error.message}`, 'error');
  } finally {
    encodeBtn.disabled = false;
    setTimeout(() => hideProgress(), 500);
  }
});

/* initial render */
renderSelected();
</script>
</body>
</html>