<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DULAS — Enhanced Encoder</title>
<style>
  :root{
    --bg1:#14142b; --bg2:#2b2a59;
    --card: rgba(255,255,255,0.06);
    --accent:#7c5cff;
    --accent-2:#00d4ff;
    --btn:#00c6ff;
    --success: #00c896;
    --error: #ff4d7c;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body{
    margin:0; min-height:100vh;
    background: linear-gradient(180deg,var(--bg1),var(--bg2));
    color:#eaf0ff; display:flex; align-items:center; justify-content:center;
    padding:18px;
  }
  .wrap{
    width:100%; max-width:920px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.1));
    border-radius:14px; padding:18px; box-shadow: 0 8px 40px rgba(2,6,23,0.6);
  }
  header{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  h1{margin:0; font-size:20px; letter-spacing:0.2px}
  .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  select,input[type="file"]{padding:10px 12px; border-radius:10px; border:none; background:var(--card); color:inherit;}
  input[type="password"]{padding:10px 12px; border-radius:10px; border:none; background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit;}
  button.primary{
    background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#012; border:none; padding:10px 16px; border-radius:10px; cursor:pointer;
    box-shadow: 0 6px 18px rgba(124,92,255,0.18), inset 0 -2px 0 rgba(0,0,0,0.12);
    transition: all 0.2s ease;
  }
  button.primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 22px rgba(124,92,255,0.25), inset 0 -2px 0 rgba(0,0,0,0.12);
  }
  button.primary:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }
  .main{display:flex; gap:16px; margin-top:14px; flex-wrap:wrap}
  .left{flex:1; min-width:240px}
  .right{width:360px; max-width:100%; background:rgba(255,255,255,0.02); padding:12px; border-radius:12px; height:420px; overflow:auto}
  .file-list{display:flex; flex-direction:column; gap:10px}
  .file-item{display:flex; gap:10px; align-items:center; background:rgba(0,0,0,0.25); padding:8px; border-radius:8px; position: relative;}
  .file-item .remove-btn {
    position: absolute;
    top: -5px;
    right: -5px;
    background: var(--error);
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .thumb{width:52px; height:52px; border-radius:8px; display:flex; align-items:center; justify-content:center; overflow:hidden; background:rgba(255,255,255,0.03)}
  .thumb img{width:100%; height:100%; object-fit:cover}
  .meta{flex:1; min-width:0}
  .meta .name{font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .meta .sub{font-size:12px; opacity:0.7}
  .download-links{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
  a.dl{padding:8px 12px; border-radius:8px; background:linear-gradient(90deg,#e9f0ff, #c8e9ff); color:#013; text-decoration:none; font-weight:600; display:inline-block; transition: all 0.2s ease;}
  a.dl:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  .hint{font-size:13px; opacity:0.8}
  .footer{margin-top:12px; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  .progress-bar {
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 8px;
    display: none;
  }
  .progress-bar .progress {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent-2));
    width: 0%;
    transition: width 0.3s ease;
  }
  .status-message {
    padding: 8px 12px;
    border-radius: 6px;
    margin-top: 10px;
    font-size: 13px;
    display: none;
  }
  .status-success {
    background: rgba(0,200,150,0.15);
    color: var(--success);
    display: block;
  }
  .status-error {
    background: rgba(255,77,124,0.15);
    color: var(--error);
    display: block;
  }
  .password-section {
    margin-top: 10px;
    padding: 10px;
    background: rgba(255,255,255,0.03);
    border-radius: 8px;
    border-left: 3px solid var(--accent);
  }
  .file-list-container {
    max-height: 300px;
    overflow-y: auto;
    margin-top: 10px;
    border: 1px solid rgba(255,255,255,0.05);
    border-radius: 8px;
    padding: 8px;
  }
  .compression-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    background: rgba(0,200,150,0.2);
    color: var(--success);
    font-size: 11px;
    margin-left: 8px;
  }
  @media (max-width:700px){
    .main{flex-direction:column}
    .right{height:320px}
    .controls {
      flex-direction: column;
      align-items: stretch;
    }
  }
</style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div>
        <h1>DULAS Enhanced Encoder</h1>
        <div class="hint">Create a private .dls container with compression. Up to 10 files</div>
      </div>

      <div class="controls" aria-hidden="false">
        <label for="typeSelect" class="hint">Type:</label>
        <select id="typeSelect" aria-label="Choose type">
          <option value="image">Images</option>
          <option value="audio">Audio</option>
          <option value="video">Video</option>
          <option value="pdf">PDF</option>
          <option value="other">Other files</option>
        </select>

        <input id="fileInput" type="file" multiple aria-label="Choose files (up to 10)" accept="*/*"/>
      </div>
    </header>

    <div class="main">
      <div class="left">
        <div style="background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); padding:12px; border-radius:12px;">
          <strong>Selected files</strong>
          <div class="progress-bar" id="encodeProgress">
            <div class="progress"></div>
          </div>
          <div class="file-list-container" id="fileListContainer">
            <div id="selectedArea" style="margin-top:10px">
              <div class="hint">Choose files. Thumbnails will appear here.</div>
            </div>
          </div>
        </div>

        <div class="password-section">
          <label for="pass" class="hint">Password (optional):</label>
          <input id="pass" type="password" placeholder="Enter password for encryption" style="width:100%; margin-top:6px;">
          <div class="hint" style="margin-top:6px;">Leave blank for no encryption</div>
        </div>

        <div style="margin-top:10px">
          <button id="clearBtn" style="padding:10px;border-radius:10px;border:none;background:#333;color:#fff; margin-right:10px;">Clear selection</button>
          <button class="primary" id="encodeBtn">Encode → .dls</button>
        </div>

        <div id="statusMessage" class="status-message"></div>

      </div>

      <aside class="right" aria-live="polite">
        <strong>Output & Downloads</strong>
        <div id="outputArea" style="margin-top:10px">
          <div class="hint">When encoding completes, download links will appear here.</div>
        </div>
      </aside>
    </div>

    <div class="footer">
      <div class="hint">DULAS format v2 — compressed binary container</div>
      <div class="hint">Files will be packaged individually (one .dls per original file)</div>
    </div>
  </div>

<script>
/* Utility: text <-> bytes */
const enc = new TextEncoder();
const dec = new TextDecoder();

// Track scroll position for file list
let scrollPosition = 0;
const fileListContainer = document.getElementById('fileListContainer');
fileListContainer.addEventListener('scroll', () => {
  scrollPosition = fileListContainer.scrollTop;
});

// Restore scroll position after UI updates
function restoreScrollPosition() {
  setTimeout(() => {
    fileListContainer.scrollTop = scrollPosition;
  }, 10);
}

/* Optimized keystream generation - faster but still secure */
function buildKeystream(password, length) {
  if (!password) return null;
  
  const pbytes = enc.encode(password);
  const out = new Uint8Array(length);
  
  // Use a faster algorithm with good distribution
  let state1 = 0x9e3779b9;
  let state2 = 0x243f6a88;
  
  for (let i = 0; i < length; i++) {
    // Mix the state with password bytes and position
    state1 = (state1 + pbytes[i % pbytes.length] + i) >>> 0;
    state2 = (state2 ^ state1) >>> 0;
    
    // Xorshift algorithm for PRNG
    state1 ^= state1 << 13;
    state1 ^= state1 >> 17;
    state1 ^= state1 << 5;
    
    state2 ^= state2 << 13;
    state2 ^= state2 >> 17;
    state2 ^= state2 << 5;
    
    out[i] = (state1 + state2) & 0xff;
  }
  
  return out;
}

/* Simple but effective compression */
function compressData(data) {
  // Use a simple run-length encoding for compression
  const compressed = [];
  let i = 0;
  
  while (i < data.length) {
    let count = 1;
    const value = data[i];
    
    // Count consecutive repeating bytes (max 255)
    while (i + count < data.length && data[i + count] === value && count < 255) {
      count++;
    }
    
    if (count > 3) {
      // Use RLE for sequences longer than 3
      compressed.push(0xFF, value, count);
      i += count;
    } else {
      // Copy literal bytes
      compressed.push(data[i++]);
    }
  }
  
  return new Uint8Array(compressed);
}

/* Create a single .dls file with enhanced structure and compression:
   [MAGIC 'DULS2' 5 bytes][VERSION 1 byte][TYPE 1 byte:1=image,2=audio,3=video,4=pdf,5=other]
   [FLAG byte: bit0=passwordProtected, bit1=compressed]
   [nameLen 2 bytes big-endian][nameBytes UTF-8]
   [metaLen 4 bytes big-endian][metaBytes UTF-8]
   [contentBytes...]  (if passwordProtected -> content was XORed with keystream)
*/
function packDulas(fileName, fileType, metaObj, contentBytes, password) {
  const MAGIC = 'DULS2'; // Updated magic for v2 format
  const nameBytes = enc.encode(fileName);
  const metaStr = JSON.stringify(metaObj);
  const metaBytes = enc.encode(metaStr);

  const flags = password ? 1 : 0;
  const typeMap = { image: 1, audio: 2, video: 3, pdf: 4, other: 5 };
  const typeByte = typeMap[fileType] || 5;

  // Apply compression to content
  let finalContent = compressData(contentBytes);
  const compressed = finalContent.length < contentBytes.length;
  if (compressed) {
    flags |= 2; // Set compressed flag
  } else {
    finalContent = contentBytes; // Use original if not compressed
  }

  // encrypt contentBytes if password
  if (password) {
    const ks = buildKeystream(password, finalContent.length);
    const encryptedContent = new Uint8Array(finalContent.length);
    for (let i = 0; i < finalContent.length; i++) {
      encryptedContent[i] = finalContent[i] ^ ks[i];
    }
    finalContent = encryptedContent;
  }

  const total =
    5 + 1 + 1 + 1 + 2 + nameBytes.length + 4 + metaBytes.length + finalContent.length;

  const out = new Uint8Array(total);
  let p = 0;
  
  // MAGIC
  for (let i = 0; i < 5; i++) out[p++] = MAGIC.charCodeAt(i);
  out[p++] = 2; // version (v2)
  out[p++] = typeByte;
  out[p++] = flags & 0xff;
  
  // name len (2 bytes big-endian)
  out[p++] = (nameBytes.length >> 8) & 0xff;
  out[p++] = nameBytes.length & 0xff;
  out.set(nameBytes, p);
  p += nameBytes.length;
  
  // meta len (4 bytes BE)
  out[p++] = (metaBytes.length >>> 24) & 0xff;
  out[p++] = (metaBytes.length >>> 16) & 0xff;
  out[p++] = (metaBytes.length >>> 8) & 0xff;
  out[p++] = (metaBytes.length) & 0xff;
  out.set(metaBytes, p);
  p += metaBytes.length;
  
  // content
  out.set(finalContent, p);
  
  return {
    data: out,
    originalSize: contentBytes.length,
    compressedSize: finalContent.length,
    compressed: compressed
  };
}

/* Helper to convert ArrayBuffer to Blob download link */
function blobToLink(uint8arr, suggestedName) {
  const blob = new Blob([uint8arr], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = suggestedName;
  a.className = 'dl';
  a.textContent = `Download ${suggestedName}`;
  a.setAttribute('aria-label', `Download ${suggestedName}`);
  return a;
}

/* UI wiring */
const fileInput = document.getElementById('fileInput');
const typeSelect = document.getElementById('typeSelect');
const passInput = document.getElementById('pass');
const encodeBtn = document.getElementById('encodeBtn');
const selectedArea = document.getElementById('selectedArea');
const outputArea = document.getElementById('outputArea');
const clearBtn = document.getElementById('clearBtn');
const encodeProgress = document.getElementById('encodeProgress');
const progressBar = encodeProgress.querySelector('.progress');
const statusMessage = document.getElementById('statusMessage');

let currentFiles = [];

fileInput.addEventListener('change', e => {
  const files = Array.from(e.target.files).slice(0, 10); // cap 10
  currentFiles = files;
  renderSelected();
});

typeSelect.addEventListener('change', () => { renderSelected(); });

clearBtn.addEventListener('click', () => {
  currentFiles = [];
  fileInput.value = '';
  renderSelected();
  outputArea.innerHTML = '<div class="hint">Cleared.</div>';
  hideStatus();
});

function showStatus(message, type = 'success') {
  statusMessage.textContent = message;
  statusMessage.className = `status-message status-${type}`;
}

function hideStatus() {
  statusMessage.style.display = 'none';
}

function showProgress(percent) {
  encodeProgress.style.display = 'block';
  progressBar.style.width = `${percent}%`;
}

function hideProgress() {
  encodeProgress.style.display = 'none';
}

function renderSelected() {
  if (currentFiles.length === 0) {
    selectedArea.innerHTML = '<div class="hint">Choose files. Thumbnails will appear here.</div>';
    return;
  }
  
  const list = document.createElement('div');
  list.className = 'file-list';
  
  currentFiles.forEach((f, idx) => {
    const item = document.createElement('div');
    item.className = 'file-item';
    item.dataset.index = idx;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.innerHTML = '×';
    removeBtn.title = 'Remove file';
    removeBtn.addEventListener('click', () => {
      currentFiles.splice(idx, 1);
      renderSelected();
    });
    
    const thumb = document.createElement('div');
    thumb.className = 'thumb';
    
    const meta = document.createElement('div');
    meta.className = 'meta';
    
    const nm = document.createElement('div');
    nm.className = 'name';
    nm.textContent = f.name;
    
    const sub = document.createElement('div');
    sub.className = 'sub';
    sub.textContent = `${(f.size / 1024).toFixed(1)} KB • ${f.type || 'unknown'}`;
    
    meta.appendChild(nm);
    meta.appendChild(sub);
    
    // Thumbnail preview based on file type
    const fileType = typeSelect.value;
    if (fileType === 'image' && f.type.startsWith('image/')) {
      const img = document.createElement('img');
      img.alt = f.name;
      thumb.appendChild(img);
      const reader = new FileReader();
      reader.onload = ev => img.src = ev.target.result;
      reader.readAsDataURL(f);
    } else if (fileType === 'pdf' && f.type === 'application/pdf') {
      thumb.innerHTML = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM15 18H9v-2h6v2zm0-4H9v-2h6v2zm-2-4V9.5L15.5 10H13z" fill="currentColor"/></svg>';
    } else if (fileType === 'video' && f.type.startsWith('video/')) {
      thumb.innerHTML = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" fill="currentColor"/></svg>';
    } else {
      // Audio or fallback
      thumb.innerHTML = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 10v4h4l5 5V5L7 10H3z" fill="currentColor"/></svg>';
    }
    
    item.appendChild(removeBtn);
    item.appendChild(thumb);
    item.appendChild(meta);
    list.appendChild(item);
  });
  
  selectedArea.innerHTML = '';
  selectedArea.appendChild(list);
  restoreScrollPosition();
}

encodeBtn.addEventListener('click', async () => {
  if (currentFiles.length === 0) {
    showStatus('No files selected', 'error');
    return;
  }
  
  const chosenType = typeSelect.value;
  encodeBtn.disabled = true;
  showProgress(0);
  hideStatus();
  
  outputArea.innerHTML = '<div class="hint">Encoding...</div>';
  
  try {
    const password = passInput.value ? passInput.value : null;
    const results = [];
    
    for (let i = 0; i < currentFiles.length; i++) {
      const f = currentFiles[i];
      showProgress((i / currentFiles.length) * 100);
      
      // Basic type validation
      if (chosenType === 'image' && !f.type.startsWith('image/')) {
        showStatus(`File "${f.name}" is not an image. Skipping.`, 'error');
        continue;
      }
      if (chosenType === 'audio' && !f.type.startsWith('audio/')) {
        showStatus(`File "${f.name}" is not an audio file. Skipping.`, 'error');
        continue;
      }
      if (chosenType === 'video' && !f.type.startsWith('video/')) {
        showStatus(`File "${f.name}" is not a video file. Skipping.`, 'error');
        continue;
      }
      if (chosenType === 'pdf' && f.type !== 'application/pdf') {
        showStatus(`File "${f.name}" is not a PDF. Skipping.`, 'error');
        continue;
      }
      
      try {
        // Read file as ArrayBuffer
        const arr = await f.arrayBuffer();
        const bytes = new Uint8Array(arr);
        const meta = {
          originalType: f.type || '',
          originalSize: f.size,
          createdAt: new Date().toISOString(),
          originalName: f.name
        };
        
        const packaged = packDulas(f.name, chosenType, meta, bytes, password);
        const suggestedName = f.name.replace(/\.[^/.]+$/, '') + '.dls';
        
        results.push({
          file: f,
          packaged: packaged.data,
          suggestedName: suggestedName,
          originalSize: packaged.originalSize,
          compressedSize: packaged.compressedSize,
          compressed: packaged.compressed
        });
      } catch (error) {
        console.error(`Error processing ${f.name}:`, error);
        showStatus(`Error processing ${f.name}: ${error.message}`, 'error');
      }
    }
    
    showProgress(100);
    outputArea.innerHTML = '';
    
    if (results.length === 0) {
      outputArea.innerHTML = '<div class="hint">No files were successfully encoded.</div>';
      showStatus('Encoding completed with errors', 'error');
    } else {
      let totalOriginalSize = 0;
      let totalCompressedSize = 0;
      
      results.forEach(result => {
        totalOriginalSize += result.originalSize;
        totalCompressedSize += result.compressedSize;
        
        const link = blobToLink(result.packaged, result.suggestedName);
        
        const box = document.createElement('div');
        box.style.marginBottom = '12px';
        box.appendChild(link);
        
        const info = document.createElement('div');
        info.className = 'hint';
        info.style.marginTop = '6px';
        
        let infoText = `Type: ${chosenType} • ${password ? 'Encrypted • ' : 'No encryption • '}`;
        if (result.compressed) {
          const spaceSaved = 100 - (result.compressedSize / result.originalSize * 100);
          infoText += `Compressed: ${(result.originalSize/1024).toFixed(1)}KB → ${(result.compressedSize/1024).toFixed(1)}KB (${spaceSaved.toFixed(1)}% saved) • `;
        } else {
          infoText += 'Not compressed • ';
        }
        infoText += result.file.name;
        
        info.textContent = infoText;
        box.appendChild(info);
        
        outputArea.appendChild(box);
      });
      
      // Add summary
      const summary = document.createElement('div');
      summary.className = 'hint';
      summary.style.marginBottom = '12px';
      summary.style.padding = '8px';
      summary.style.background = 'rgba(255,255,255,0.05)';
      summary.style.borderRadius = '6px';
      
      let summaryText = `Encoded ${results.length} file(s). `;
      if (totalCompressedSize < totalOriginalSize) {
        const compressionRatio = (100 - (totalCompressedSize / totalOriginalSize * 100)).toFixed(1);
        summaryText += `Compression: ${(totalOriginalSize/1024).toFixed(1)}KB → ${(totalCompressedSize/1024).toFixed(1)}KB (${compressionRatio}% saved). `;
      }
      summaryText += password ? 'Files are encrypted.' : 'Files are not encrypted.';
      
      summary.textContent = summaryText;
      outputArea.insertBefore(summary, outputArea.firstChild);
      
      showStatus(`Successfully encoded ${results.length} file(s)`, 'success');
    }
  } catch (error) {
    console.error('Encoding error:', error);
    outputArea.innerHTML = '<div class="hint">An error occurred during encoding.</div>';
    showStatus(`Encoding error: ${error.message}`, 'error');
  } finally {
    encodeBtn.disabled = false;
    setTimeout(() => hideProgress(), 500);
  }
});

/* initial render */
renderSelected();
</script>
</body>
</html>