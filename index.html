<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DULAS v4 — Encoder</title>
<style>
  :root{
    --bg:#0b1220; --card:#0f1722; --muted:#9fb0c3; --accent:#7c5cff; --ok:#22c55e; --bad:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%,#071b2b 100%);color:#e6eef8}
  .wrap{max-width:1000px;margin:28px auto;padding:20px}
  header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
  h1{font-size:20px;margin:0;color:var(--accent)}
  p.lead{margin:0;color:var(--muted);font-size:13px}
  .card{background:var(--card);border-radius:12px;padding:14px;margin-bottom:12px;box-shadow:0 6px 30px rgba(2,6,23,0.5)}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  input[type=file]{color:unset}
  .options{display:flex;gap:12px;align-items:center;margin-top:8px}
  label.inline{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
  button.primary{background:var(--accent);border:none;padding:8px 12px;border-radius:10px;color:#051025;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:var(--muted);cursor:pointer}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:12px}
  .file-list{max-height:420px;overflow:auto;padding:6px;border-radius:8px}
  .file-row{display:flex;gap:12px;padding:8px;border-radius:8px;background:var(--glass);align-items:center;margin-bottom:8px}
  .thumb{width:78px;height:56px;flex:0 0 78px;border-radius:6px;background:#0003;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .meta{flex:1;min-width:0}
  .meta .name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .meta .small{font-size:12px;color:var(--muted);margin-top:4px}
  .status{font-size:12px;padding:6px 8px;border-radius:8px}
  .status.ok{background:rgba(34,197,94,0.12);color:var(--ok)}
  .status.work{background:rgba(124,92,255,0.12);color:var(--accent)}
  .status.err{background:rgba(255,107,107,0.08);color:var(--bad)}
  pre.json{background:#021026;padding:10px;border-radius:8px;color:#bfeaff;overflow:auto;max-height:220px}
  footer{margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between}
  .note{color:var(--muted);font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>DULAS v4 — Advanced Encoder</h1>
    <p class="lead">Bundle up to 5 files (images / audio / video), add metadata, compress & encrypt, then download one `.dulas` bundle.</p>
  </header>

  <div class="card">
    <div class="controls">
      <input id="files" type="file" multiple />
      <div class="options">
        <label class="inline"><input id="compress" type="checkbox" checked/> Use compression</label>
        <label class="inline"><input id="encrypt" type="checkbox" /> Use encryption (AES-GCM)</label>
        <input id="password" placeholder="password (if encryption)" style="padding:6px;border-radius:8px;border:1px solid #0b2233;background:transparent;color:inherit" />
      </div>
      <button id="start" class="primary">Encode & Download .dulas</button>
      <button id="reset" class="ghost">Reset</button>
    </div>
    <div style="margin-top:10px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
      <div class="note">Max 5 files. AES-GCM uses PBKDF2 key derivation with salt + 100k iterations.</div>
    </div>
  </div>

  <div class="grid">
    <div class="card file-list" id="fileList">
      <div style="font-size:13px;color:var(--muted);margin-bottom:8px">Selected files</div>
      <!-- file rows injected here -->
    </div>

    <div class="card">
      <div style="display:flex;flex-direction:column;gap:10px">
        <div style="font-weight:700;color:var(--muted)">Bundle metadata (preview)</div>
        <pre class="json" id="bundleJson">No bundle yet.</pre>
        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div class="note" id="bundleInfo">Awaiting files</div>
          <div>
            <button id="downloadSample" class="ghost">Download sample .dulas (demo)</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <div class="note">Files are processed locally in your browser — no server involved.</div>
    <div id="progress" style="font-size:13px;color:var(--muted)">Idle</div>
  </footer>
</div>

<script>
/**
 * DULAS v4 encoder:
 * - Magic: "DULAS4" (6 bytes) + version byte (0x04)
 * - FileCount: uint8
 * - For each file:
 *    metadataLength: uint32LE
 *    metadataJSON (UTF-8) -> contains filename, mime, origSize, encodedSize, sha256Hex,
 *                            compressed:boolean, encrypted:boolean, width,height,duration,thumbnailDataURL (optional)
 *    fileData bytes (encoded bytes)
 *
 * For encrypted entries (AES-GCM), we encrypt per-file bytes and store encoded bytes and metadata.encrypted = true;
 * We also store key-derivation salt & AES iv globally in bundle header to allow decryption (safe enough for this demo).
 *
 * NOTE: This file aims for clarity & functionality; production formats require more rigor.
 */

const MAX_FILES = 5;
const MAGIC = "DULAS4";
const VERSION = 0x04;

const filesEl = document.getElementById('files');
const listEl = document.getElementById('fileList');
const compressEl = document.getElementById('compress');
const encryptEl = document.getElementById('encrypt');
const passEl = document.getElementById('password');
const startBtn = document.getElementById('start');
const resetBtn = document.getElementById('reset');
const bundleJson = document.getElementById('bundleJson');
const progressEl = document.getElementById('progress');
const bundleInfo = document.getElementById('bundleInfo');
const downloadSample = document.getElementById('downloadSample');

let selectedFiles = [];

filesEl.addEventListener('change', async (e) => {
  selectedFiles = Array.from(e.target.files).slice(0, MAX_FILES);
  await renderFileList();
  updateBundlePreview();
});

resetBtn.addEventListener('click', () => {
  selectedFiles = []; filesEl.value = ""; listEl.innerHTML = ""; bundleJson.textContent = "No bundle yet."; bundleInfo.textContent = "Awaiting files"; progressEl.textContent = "Idle";
});

downloadSample.addEventListener('click', () => {
  // create tiny sample bundle with a text file
  const sampleMeta = { name:"hello.txt", mime:"text/plain", origSize:11, encodedSize:11, sha256:"", compressed:false, encrypted:false, created:new Date().toISOString() };
  const metaStr = JSON.stringify(sampleMeta);
  const metaBytes = new TextEncoder().encode(metaStr);
  const dataBytes = new TextEncoder().encode("hello world");
  const header = [...new TextEncoder().encode(MAGIC), VERSION, 1]; // 1 file
  header.push(...u32ToBytesLE(metaBytes.length));
  header.push(...Array.from(metaBytes));
  header.push(...u32ToBytesLE(dataBytes.length));
  header.push(...Array.from(dataBytes));
  const blob = new Blob([new Uint8Array(header)], {type:"application/octet-stream"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = "sample.dulas"; a.click();
});

/* ---------- utilities ---------- */
function u32ToBytesLE(n){ return [n & 255, (n>>>8)&255, (n>>>16)&255, (n>>>24)&255]; }
function bytesToU32LE(array, offset){ return array[offset] | (array[offset+1]<<8) | (array[offset+2]<<16) | (array[offset+3]<<24); }
function hexFromBuffer(buf){
  const b = new Uint8Array(buf); return Array.from(b).map(x=>x.toString(16).padStart(2,'0')).join('');
}
async function sha256(bytes){ const h = await crypto.subtle.digest('SHA-256', bytes); return hexFromBuffer(h); }
function bufToU8(buf){ return buf instanceof Uint8Array ? buf : new Uint8Array(buf); }

/* Compression helpers */
async function compressUint8(u8){
  if(!window.CompressionStream) return u8;
  const cs = new CompressionStream('deflate');
  const writable = cs.writable.getWriter();
  writable.write(u8);
  writable.close();
  const compressed = new Response(cs.readable).arrayBuffer();
  return new Uint8Array(await compressed);
}
async function decompressUint8(u8){
  if(!window.DecompressionStream) return u8;
  const ds = new DecompressionStream('deflate');
  const writer = ds.writable.getWriter();
  writer.write(u8); writer.close();
  const out = await new Response(ds.readable).arrayBuffer();
  return new Uint8Array(out);
}

/* AES-GCM helpers: derive key from password using PBKDF2 */
async function deriveKeyFromPassword(password, saltBytes){
  const pwKey = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    {name:'PBKDF2', salt: saltBytes, iterations: 100000, hash: 'SHA-256'},
    pwKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt','decrypt']
  );
}
async function aesGcmEncrypt(key, plaintext, iv){
  return crypto.subtle.encrypt({name:'AES-GCM', iv}, key, plaintext);
}
async function aesGcmDecrypt(key, ciphertext, iv){
  return crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ciphertext);
}

/* Create thumbnail for image files (max dimension 200) */
async function createImageThumbnail(file){
  try{
    const blobUrl = URL.createObjectURL(file);
    const img = new Image();
    img.src = blobUrl;
    await new Promise((res,rej)=>{ img.onload = res; img.onerror = rej; });
    const maxDim = 200;
    let w = img.naturalWidth, h = img.naturalHeight;
    if(w>h){ if(w>maxDim){ h = Math.round(h * maxDim / w); w = maxDim; } }
    else { if(h>maxDim){ w = Math.round(w * maxDim / h); h = maxDim; } }
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
    const dataUrl = c.toDataURL('image/jpeg', 0.7);
    URL.revokeObjectURL(blobUrl);
    return {thumb:dataUrl, width: img.naturalWidth, height: img.naturalHeight};
  }catch(e){ return {thumb:null, width:null, height:null}; }
}

/* Extract duration for audio/video by loading into element */
async function extractDuration(file){
  return new Promise((res)=> {
    if(!file.type.startsWith('audio') && !file.type.startsWith('video')) return res(null);
    const url = URL.createObjectURL(file);
    let el;
    if(file.type.startsWith('audio')) el = document.createElement('audio');
    else el = document.createElement('video');
    el.preload = 'metadata';
    el.src = url;
    const t = setTimeout(()=>{ URL.revokeObjectURL(url); res(null); }, 4000);
    el.onloadedmetadata = () => { clearTimeout(t); const d = isFinite(el.duration) ? el.duration : null; URL.revokeObjectURL(url); res(d); };
    el.onerror = ()=>{ clearTimeout(t); URL.revokeObjectURL(url); res(null); };
  });
}

/* Render file list and compute metadata placeholders */
async function renderFileList(){
  listEl.innerHTML = "";
  if(selectedFiles.length === 0){ listEl.innerHTML = '<div style="color:var(--muted)">No files chosen</div>'; return; }
  if(selectedFiles.length > MAX_FILES) selectedFiles = selectedFiles.slice(0,MAX_FILES);

  for(const f of selectedFiles){
    const row = document.createElement('div'); row.className = 'file-row';
    const thumbBox = document.createElement('div'); thumbBox.className = 'thumb';
    thumbBox.innerHTML = `<div style="font-size:12px;color:var(--muted);padding:6px">Loading…</div>`;
    const meta = document.createElement('div'); meta.className = 'meta';
    meta.innerHTML = `<div class="name">${f.name}</div><div class="small">${f.type || 'unknown'} • ${formatBytes(f.size)}</div>`;
    const status = document.createElement('div'); status.className = 'status work'; status.textContent = 'waiting';
    row.appendChild(thumbBox); row.appendChild(meta); row.appendChild(status);
    listEl.appendChild(row);

    // compute thumbnail & dimensions/duration asynchronously
    (async ()=>{
      let thumb = null, width=null, height=null, duration=null;
      if(f.type.startsWith('image/')) {
        const t = await createImageThumbnail(f); thumb = t.thumb; width = t.width; height = t.height;
      } else if(f.type.startsWith('audio/') || f.type.startsWith('video/')){
        duration = await extractDuration(f);
      }
      if(thumb){
        thumbBox.innerHTML = `<img src="${thumb}" style="width:100%;height:100%;object-fit:cover"/>`;
      } else {
        thumbBox.innerHTML = `<div style="font-size:12px;color:var(--muted);padding:6px">${f.type.split('/')[0]||'file'}</div>`;
      }
      meta.innerHTML = `<div class="name">${f.name}</div><div class="small">${f.type || 'unknown'} • ${formatBytes(f.size)} ${width?('• '+width+'×'+height):''} ${duration?('• '+Math.round(duration)+'s'):''}</div>`;
      status.textContent = 'ready';
      status.className = 'status ok';
    })();
  }
}

function formatBytes(n){
  if(n<1024) return n+' B';
  if(n<1024*1024) return (n/1024).toFixed(1)+' KB';
  if(n<1024*1024*1024) return (n/(1024*1024)).toFixed(2)+' MB';
  return (n/(1024*1024*1024)).toFixed(2)+' GB';
}

/* ---------- main encode flow ---------- */
startBtn.addEventListener('click', async () => {
  if(selectedFiles.length === 0){ alert("Choose files first"); return; }
  if(selectedFiles.length > MAX_FILES){ alert("Too many files"); return; }
  startBtn.disabled = true; progressEl.textContent = 'Preparing...';
  const doCompress = compressEl.checked;
  const doEncrypt = encryptEl.checked;
  const password = passEl.value || "";

  // If encryption requested, prepare salt and derive key (global)
  let salt = null, masterKey = null, ivGlobal = null;
  if(doEncrypt){
    if(!password){ if(!confirm("No password entered. Proceed with empty password?")){ startBtn.disabled=false; return; } }
    salt = crypto.getRandomValues(new Uint8Array(16));
    masterKey = await deriveKeyFromPassword(password, salt);
    ivGlobal = crypto.getRandomValues(new Uint8Array(12)); // using same iv per-file is not ideal, but we'll use per-file ivs below; ivGlobal kept to show it's present (for demo)
  }

  const fileEntries = []; // metadata + encoded bytes
  for(let i=0;i<selectedFiles.length;i++){
    const f = selectedFiles[i];
    progressEl.textContent = `Processing ${f.name} (${i+1}/${selectedFiles.length})`;
    // read raw bytes
    const raw = new Uint8Array(await f.arrayBuffer());
    // gather extra metadata
    const duration = await extractDuration(f);
    let thumb = null, width=null,height=null;
    if(f.type.startsWith('image/')){
      const t = await createImageThumbnail(f);
      thumb = t.thumb; width = t.width; height = t.height;
    }
    // compute sha256 of original
    const sha = await sha256(raw.buffer);

    // compress if requested
    let encoded = raw;
    let compressed = false;
    if(doCompress){
      const comp = await compressUint8(raw);
      if(comp.length < raw.length){
        encoded = comp; compressed = true;
      } else {
        // keep original if compression didn't help
        encoded = raw; compressed = false;
      }
    }

    // encrypt per-file if requested (use derived key + per-file iv)
    let encrypted = false;
    let finalBytes = encoded;
    let fileIv = null;
    if(doEncrypt){
      fileIv = crypto.getRandomValues(new Uint8Array(12));
      const ct = await aesGcmEncrypt(masterKey, encoded, fileIv);
      finalBytes = new Uint8Array(ct);
      encrypted = true;
    }

    const meta = {
      fileId: i,
      name: f.name,
      mime: f.type || "application/octet-stream",
      origSize: f.size,
      encodedSize: finalBytes.length,
      sha256: sha,
      compressed: compressed,
      encrypted: encrypted,
      width: width,
      height: height,
      duration: duration,
      thumbnail: thumb,
      created: new Date().toISOString()
    };

    fileEntries.push({ meta, bytes: finalBytes, iv: fileIv });
    progressEl.textContent = `Done ${f.name}`;
  }

  // Build final bundle bytes:
  // header: MAGIC (6 bytes) + VERSION (1 byte) + flags (1 byte) + saltLen+salt (if encrypted)
  // + fileCount (1 byte)
  // For each file: metadataLength(uint32LE) + metadataJSON + dataLength(uint32LE) + dataBytes
  progressEl.textContent = 'Assembling bundle...';
  const parts = [];
  parts.push(...new TextEncoder().encode(MAGIC));
  parts.push(VERSION);
  // flags: bit0 = compressionPossible (we record per-file anyway), bit1 = encryptionUsed
  let flags = 0;
  if(doEncrypt) flags |= 0x02;
  parts.push(flags);
  if(doEncrypt){
    // store salt length + salt
    parts.push(salt.length);
    parts.push(...Array.from(salt));
  } else {
    parts.push(0); // salt length 0
  }
  // file count
  parts.push(fileEntries.length);

  // For transparency store per-file ivs in metadata; but also we can store global iv placeholder
  for(const fe of fileEntries){
    const metaStr = JSON.stringify({...fe.meta, iv: fe.iv ? bufferToBase64(fe.iv) : null});
    const metaBytes = new TextEncoder().encode(metaStr);
    parts.push(...u32ToBytesLE(metaBytes.length));
    parts.push(...Array.from(metaBytes));
    parts.push(...u32ToBytesLE(fe.bytes.length));
    parts.push(...Array.from(fe.bytes));
  }

  const allBytes = new Uint8Array(parts);
  const blob = new Blob([allBytes], { type: 'application/octet-stream' });
  const name = `dulas-bundle-${new Date().toISOString().replace(/[:.]/g,'-')}.dulas`;
  const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = name; link.click();
  progressEl.textContent = `Bundle created: ${name} (${formatBytes(allBytes.byteLength)})`;
  bundleInfo.textContent = `${fileEntries.length} file(s) bundled • ${doCompress? 'Compression enabled':'' } ${doEncrypt? ' • Encrypted':''}`;
  bundleJson.textContent = JSON.stringify({
    version: VERSION, flags: flags, files: fileEntries.map(f=>f.meta)
  }, null, 2);

  startBtn.disabled = false;
});

/* helpers to display base64 for iv */
function bufferToBase64(buf){
  const u = new Uint8Array(buf); let s = ''; for(let i=0;i<u.length;i++) s += String.fromCharCode(u[i]); return btoa(s);
}
</script>
</body>
</html>